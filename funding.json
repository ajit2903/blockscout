[
  {
    "address": "0x2d342e80F94ff3119940B862caCE536303506237",
    "name": "Beacoin",
    "bytecode": "0xfe",
    "compiler": "Not installed",
    "source": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.4.21 <0.9.0;\n\n/** @title Interface for providing gas estimation for retryable auto-redeems and constructing outbox proofs\n *  @notice This contract doesn't exist on-chain. Instead it is a virtual interface accessible at\n *  0x00000000000000000000000000000000000000C8\n *  This is a cute trick to allow an Arbitrum node to provide data without us having to implement additional RPCs\n */\ninterface NodeInterface {\n    /**\n     * @notice Simulate the execution of a retryable ticket\n     * @dev Use eth_estimateGas on this call to estimate gas usage of retryable ticket\n     *      Since gas usage is not yet known, you may need to add extra deposit (e.g. 1e18 wei) during estimation\n     * @param sender unaliased sender of the L1 and L2 transaction\n     * @param deposit amount to deposit to sender in L2\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param data ABI encoded data of L2 message\n     */\n    function estimateRetryableTicket(\n        address sender,\n        uint256 deposit,\n        address to,\n        uint256 l2CallValue,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice Constructs an outbox proof of an l2->l1 send's existence in the outbox accumulator.\n     * @dev Use eth_call to call.\n     * @param size the number of elements in the accumulator\n     * @param leaf the position of the send in the accumulator\n     * @return send the l2->l1 send's hash\n     * @return root the root of the outbox accumulator\n     * @return proof level-by-level branch hashes constituting a proof of the send's membership at the given size\n     */\n    function constructOutboxProof(uint64 size, uint64 leaf)\n        external\n        view\n        returns (\n            bytes32 send,\n            bytes32 root,\n            bytes32[] memory proof\n        );\n\n    /**\n     * @notice Finds the L1 batch containing a requested L2 block, reverting if none does.\n     * Use eth_call to call.\n     * Throws if block doesn't exist, or if block number is 0. Use eth_call\n     * @param blockNum The L2 block being queried\n     * @return batch The sequencer batch number containing the requested L2 block\n     */\n    function findBatchContainingBlock(uint64 blockNum) external view returns (uint64 batch);\n\n    /**\n     * @notice Gets the number of L1 confirmations of the sequencer batch producing the requested L2 block\n     * This gets the number of L1 confirmations for the input message producing the L2 block,\n     * which happens well before the L1 rollup contract confirms the L2 block.\n     * Throws if block doesnt exist in the L2 chain.\n     * @dev Use eth_call to call.\n     * @param blockHash The hash of the L2 block being queried\n     * @return confirmations The number of L1 confirmations the sequencer batch has. Returns 0 if block not yet included in an L1 batch.\n     */\n    function getL1Confirmations(bytes32 blockHash) external view returns (uint64 confirmations);\n\n    /**\n     * @notice Same as native gas estimation, but with additional info on the l1 costs.\n     * @dev Use eth_call to call.\n     * @param data the tx's calldata. Everything else like \"From\" and \"Gas\" are copied over\n     * @param to the tx's \"To\" (ignored when contractCreation is true)\n     * @param contractCreation whether \"To\" is omitted\n     * @return gasEstimate an estimate of the total amount of gas needed for this tx\n     * @return gasEstimateForL1 an estimate of the amount of gas needed for the l1 component of this tx\n     * @return baseFee the l2 base fee\n     * @return l1BaseFeeEstimate ArbOS's l1 estimate of the l1 base fee\n     */\n    function gasEstimateComponents(\n        address to,\n        bool contractCreation,\n        bytes calldata data\n    )\n        external\n        payable\n
